<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>repl.it</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
   
    <canvas width="500" height="500" id="canvas">not supported</canvas>
    
    <script src="script.js">
    </script>
    

    <br>
    <label>delay (ms)</label>
    <input type="number" value="0" id="delay">
    <br>
    <button id="reset_button">reset</button>
    <button id="breadth first">Breadth First Search</button>
    <script>

      let breadth_first_button = document.getElementById("breadth first");
      let reset_button = document.getElementById("reset_button");
      breadth_first_button.addEventListener('click', breadth_wrapper);
      reset_button.addEventListener('click', reset);


      const sleep = (milliseconds) => {
        return new Promise(resolve => setTimeout(resolve, milliseconds))
      }

      function getStartId(){
        let start = Graph.getChildrenByText("start");
        
        return start[0].id;
      }

      function getEndId(){
        let end = Graph.getChildrenByText("end");
        
        return end[0].id;
      }

      function reset(){
        nodeking.edges.map(edge => edge.color = "black");
      }

      async function breadth_wrapper(){
        reset();
        let delay =  Number(document.getElementById("delay").value);
        console.log(delay);
        console.log("start");
        console.log("start "+getStartId());
        console.log("end "+getEndId());
        let thing = await Graph.breadthFirstSearch(getStartId(), getEndId());
        console.log("done")
        
      }

      

      async function breadth(delay = 0){
        goal = end;
        start = getstart();
        if(!start){
          alert("no starting node");
        }
        discovered = [start];
        
        visited = []
        current = start;
        stacks = {}
        stacks[current.id]=[start.id]
        paths = {}

        while(true){
          console.log(delay);
          await sleep(delay);
          
          if(current.text == "end"){
            current.set_color("black");
            break;
          }
          if(!current.children){
            continue;
          }
          for(child of current.children.map((id)=>nodeking.getChild(id))){
            if(visited.some(node => node.id ===  child.id) || discovered.some(node => node.id == child.id)){
              console.log("already visited or discovered");
            }
            else{
              discovered.push(child);
              
              temp = [...stacks[current['id']]]
              temp.push(child.id)
              stacks[child['id']] = temp;
            }

          }
          
          old = current;
          visited.push(discovered.shift());

          current = discovered[0];
          
          current.set_color("blue");
            
          
          old.set_color("black");
          
        }
        
        if(current.text == "end"){
          for(let i = 0; i<stacks[current.id].length-1; i++){
            path_list = stacks[current.id];
            nodeking.getEdge(path_list[i], path_list[i+1]).color = "red";
          }
        }else{
          alert("no soultion found");
        }



        

       
        console.log(paths);
        level = 0
        


        

      }




      function log_all_values(){
        nodeking.objs.map((node)=>console.log(node.value));
      }
    </script>
    <script>
      let canvas = document.getElementById("canvas");
      let nodeking = Graph.init("canvas");
      let start = new Graph.node(100, 100, 40, "start");
      let end = new Graph.node(400, 400, 40, "end");
      start.connect(end);
      
    </script>
  </body>
</html>